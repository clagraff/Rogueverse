# Agent Guidelines for rogueverse

## Build & Test Commands
- `flutter run` - Run the app
- `flutter test` - Run all tests
- `flutter test test/widget_test.dart` - Run a single test file
- `flutter analyze` - Lint the codebase
- `dart run build_runner build` - Generate mapper files for dart_mappable

The app should NEVER be ran (`flutter run`) without explicit instructions to
do so. 
Prefer `flutter analyze` or `flutter build` over `flutter run` in almost all cases.

For `flutter analyze`, prefer running it over the specific files changed (if any)
instead of the whole project for speed & efficiency.

After making changes, run `flutter analyze` to catch and fix:
- Unused imports
- Unnecessary imports (duplicates from re-exporting files)
- Unused variables/fields
- Other lint warnings

## Code Style

### Imports
- Use `package:rogueverse/` for all internal imports (never relative imports)
- Group imports: dart, flutter/flame, packages, project (separated by blank lines)
- Hide conflicting imports explicitly (e.g., `import 'package:flame/components.dart' hide World;`)
- Use `ecs/ecs.dart` for ECS imports (it re-exports all ECS modules)
- Remove unnecessary/duplicate imports flagged by `flutter analyze`

### Formatting & Structure
- Use `flutter_lints` rules (configured in `analysis_options.yaml`)

### Auto-Generated Files (DO NOT EDIT MANUALLY)
The following files are auto-generated and should never be edited by hand:
- `*.mapper.dart` - Generated by dart_mappable via build_runner
- `*.init.dart` - Generated by dart_mappable via build_runner

To regenerate these files after changing `@MappableClass()` components:
```bash
dart run build_runner build --delete-conflicting-outputs
```

### Types & Annotations
- All components must use `@MappableClass()` annotation and implement `Component` interface
- Components must define `String get componentType` getter returning their type name
- Use `part 'filename.mapper.dart';` for files with `@MappableClass()` annotations
- Prefer explicit types over `var` for public APIs

### Naming Conventions
- Classes: PascalCase (e.g., `LocalPosition`, `MoveByIntent`)
- Files: snake_case matching class name (e.g., `components.dart`, `game_area.dart`)
- Private fields: prefix with underscore (e.g., `_templateEditingWorld`)

### Error Handling
- Use exceptions for invalid state (e.g., `throw Exception("message")`)
- Add TODO comments for future improvements

### Logging
Use the `logging` package for runtime logging. Logger setup is in `lib/main.dart`.

**Logger instantiation:** Always declare a class-level logger field, never create loggers inline:
```dart
// GOOD - class-level static field (preferred for most classes)
class MySystem {
  static final _logger = Logger('MySystem');
}

// GOOD - instance field (when logger name needs runtime info)
class MyComponent {
  final _logger = Logger('MyComponent');
}

// BAD - creates new logger instance every call
Logger('MySystem').info('message');
```

**Log levels** (from most to least verbose):
- `finest` - Internal state details useful for deep debugging (loop iterations, cache hits)
- `finer` - Detailed flow tracing (rarely needed)
- `fine` - Operation tracking within a system (entity processed, step completed)
- `info` - Significant state changes and events (game loaded, mode changed, save completed)
- `warning` - Recoverable issues that may need attention (missing optional data, fallback used)
- `severe` - Errors that affect functionality (failed to load, operation failed)

**Guidelines:**
- Log at entry points and significant state transitions, not every internal step
- Include relevant context as a Map: `_logger.info('entity moved', {'id': e.id, 'to': pos})`
- For `severe`, include error and stack trace: `_logger.severe('failed', error, stackTrace)`
- Avoid duplicate logging - if a caller logs an event, callees shouldn't log the same event
- Use `finest`/`fine` liberally for debugging, but keep `info` sparse for production clarity
