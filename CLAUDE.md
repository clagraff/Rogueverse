# Rogueverse Project Guidelines

## Build & Test Commands

- `flutter run` - Run the app
- `flutter test` - Run all tests
- `flutter test test/widget_test.dart` - Run a single test file
- `flutter analyze` - Lint the codebase
- `dart run build_runner build` - Generate mapper files for dart_mappable

The app should NEVER be ran (`flutter run`) without explicit instructions to do so.

**Prefer `flutter analyze` over `flutter build`** - building takes too long and analyze is sufficient for catching most issues.

For `flutter analyze`, prefer running it over the specific files changed (if any) instead of the whole project for speed & efficiency.

After making changes, run `flutter analyze` to catch and fix:
- Unused imports
- Unnecessary imports (duplicates from re-exporting files)
- Unused variables/fields
- Other lint warnings

## Code Style

### Imports

- Use `package:rogueverse/` for all internal imports (never relative imports)
- Group imports: dart, flutter/flame, packages, project (separated by blank lines)
- Hide conflicting imports explicitly (e.g., `import 'package:flame/components.dart' hide World;`)
- Use `ecs/ecs.dart` for ECS imports (it re-exports all ECS modules)
- Remove unnecessary/duplicate imports flagged by `flutter analyze`

### Formatting & Structure

- Use `flutter_lints` rules (configured in `analysis_options.yaml`)

### Auto-Generated Files (DO NOT EDIT MANUALLY)

The following files are auto-generated and should never be edited by hand:
- `*.mapper.dart` - Generated by dart_mappable via build_runner
- `*.init.dart` - Generated by dart_mappable via build_runner

To regenerate these files after changing `@MappableClass()` components:
```bash
dart run build_runner build --delete-conflicting-outputs
```

### Types & Annotations

- All components must use `@MappableClass()` annotation and implement `Component` interface
- Components must define `String get componentType` getter returning their type name
- Use `part 'filename.mapper.dart';` for files with `@MappableClass()` annotations
- Prefer explicit types over `var` for public APIs

### Component Immutability

- **All component properties must be `final` (immutable)**
- When updating state, create a new component instance and `upsert()` it
- Reason: `entity.get<T>()` returns template components by reference, not copy. Mutating them affects all instances inheriting from that template.
- TODO: Audit existing components to ensure all properties are `final`

### Naming Conventions

- Classes: PascalCase (e.g., `LocalPosition`, `MoveByIntent`)
- Files: snake_case matching class name (e.g., `components.dart`, `game_area.dart`)
- Private fields: prefix with underscore (e.g., `_templateEditingWorld`)

### Error Handling

- Use exceptions for invalid state (e.g., `throw Exception("message")`)
- Add TODO comments for future improvements

### Logging

Use the `logging` package for runtime logging. Logger setup is in `lib/main.dart`.

**Logger instantiation:** Always declare a class-level logger field, never create loggers inline:
```dart
// GOOD - class-level static field (preferred for most classes)
class MySystem {
  static final _logger = Logger('MySystem');
}

// GOOD - instance field (when logger name needs runtime info)
class MyComponent {
  final _logger = Logger('MyComponent');
}

// BAD - creates new logger instance every call
Logger('MySystem').info('message');
```

**Log levels** (from most to least verbose):
- `finest` - Internal state details useful for deep debugging (loop iterations, cache hits)
- `finer` - Detailed flow tracing (rarely needed)
- `fine` - Operation tracking within a system (entity processed, step completed)
- `info` - Significant state changes and events (game loaded, mode changed, save completed)
- `warning` - Recoverable issues that may need attention (missing optional data, fallback used)
- `severe` - Errors that affect functionality (failed to load, operation failed)

**Guidelines:**
- Log at entry points and significant state transitions, not every internal step
- Include relevant context as a Map: `_logger.info('entity moved', {'id': e.id, 'to': pos})`
- For `severe`, include error and stack trace: `_logger.severe('failed', error, stackTrace)`
- Avoid duplicate logging - if a caller logs an event, callees shouldn't log the same event
- Use `finest`/`fine` liberally for debugging, but keep `info` sparse for production clarity

## Keyboard Navigation Architecture

### Hierarchical Focus Model

UI components use a **focus-based hierarchical navigation** pattern where each navigation level owns its own `FocusNode`. This enables spatial navigation (WASD/arrows) that moves between levels rather than just within lists.

**Key principles:**
- Each navigation level has its own `FocusNode` and handles its own keyboard events
- When entering a child level, the child **requests focus**
- When exiting (W at top / Escape), the child calls `parentFocusNode.requestFocus()`
- Visual highlights only appear when that level **has focus**

**Navigation flow example (Settings tab):**
```
CharacterScreenOverlay (FocusNode) <- handles Tab/Esc to close, Q/E for main tabs
    -> SettingsTabContent (FocusNode) <- handles A/D for sub-tabs, S to enter content
        -> GeneralSettingsEditor (FocusNode) <- handles W/S navigation, Enter/Space toggle
```

### Standard Key Bindings

Use the `KeyBindingService` for configurable bindings. Never hardcode WASD - always check both arrow keys AND the menu.* keybindings:

```dart
// Correct pattern - supports both arrows and configurable keys
if (key == LogicalKeyboardKey.arrowUp ||
    keybindings.matches('menu.up', {key})) { ... }

if (key == LogicalKeyboardKey.arrowLeft ||
    keybindings.matches('menu.left', {key})) { ... }
```

**Standard bindings:**
- `menu.up/down/left/right` - Directional navigation (default: WASD)
- `menu.select` - Activate/confirm (default: E)
- `menu.back` - Go back/cancel (default: Q)
- `ui.tab_prev/ui.tab_next` - Switch main tabs (default: Q/E)

### Focus-Aware Visual Feedback

Selection highlights should only appear when the widget **has focus**:

```dart
return ListenableBuilder(
  listenable: _focusNode,
  builder: (context, child) {
    final hasFocus = _focusNode.hasFocus;

    return KeyboardListener(
      focusNode: _focusNode,
      onKeyEvent: _handleKeyEvent,
      child: ListView(
        children: items.map((item) => _buildItem(
          isSelected: hasFocus && index == _selectedIndex,  // Focus-aware
        )).toList(),
      ),
    );
  },
);
```

### Highlight Styling

Use **border-based highlights** (not fill color) for items containing controls like switches/checkboxes. This keeps the control's on/off state visible:

```dart
decoration: BoxDecoration(
  color: isSelected ? colorScheme.surfaceContainerHighest : null,
  borderRadius: BorderRadius.circular(4),
  border: isSelected
      ? Border.all(color: colorScheme.primary, width: 2)
      : null,
),
```

For tab buttons or items without embedded controls, fill color is acceptable.

### Widget Parameter Pattern

Widgets in the focus hierarchy accept these parameters:

```dart
class MyNavigableWidget extends StatefulWidget {
  /// Focus node for this widget. If provided externally, caller controls
  /// when this widget receives focus.
  final FocusNode? focusNode;

  /// Parent's focus node. When user exits (W at top / Escape), focus returns here.
  final FocusNode? parentFocusNode;

  const MyNavigableWidget({
    super.key,
    this.focusNode,
    this.parentFocusNode,
  });
}
```

When `focusNode` is null, the widget creates and manages its own. When provided, the parent controls focus timing.

## ECS Architecture

The game uses an Entity-Component-System architecture. See `/new-component` skill for creating new components.

## UI Constants

Standard spacing, elevation, and sizing values are in `lib/app/ui_constants.dart`. Use these instead of magic numbers.
